{"version":3,"file":"morphism.js","mappings":"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","sources":["webpack://Morphism/webpack/universalModuleDefinition","webpack://Morphism/webpack/bootstrap","webpack://Morphism/webpack/runtime/define property getters","webpack://Morphism/webpack/runtime/hasOwnProperty shorthand","webpack://Morphism/webpack/runtime/make namespace object","webpack://Morphism/./src/helpers.ts","webpack://Morphism/./src/validation/reporter.ts","webpack://Morphism/./src/MorphismTree.ts","webpack://Morphism/./src/validation/validators/ValidatorError.ts","webpack://Morphism/./src/MorphismDecorator.ts","webpack://Morphism/./src/validation/validators/LinkedList.ts","webpack://Morphism/./src/validation/validators/StringValidator.ts","webpack://Morphism/./src/validation/Validation.ts","webpack://Morphism/./src/morphism.ts","webpack://Morphism/./src/validation/validators/NumberValidator.ts","webpack://Morphism/./src/validation/validators/BooleanValidator.ts","webpack://Morphism/./src/MorphismRegistry.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Morphism\"] = factory();\n\telse\n\t\troot[\"Morphism\"] = factory();\n})(this, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { ActionSelector, ActionAggregator, ActionFunction } from './types';\r\n\r\n/**\r\n * Symbol identifier used to store options on a Morphism schema. Using the `createSchema` helper to avoid using the symbol directly.\r\n *\r\n * @example\r\n * ```typescript\r\n * import { SCHEMA_OPTIONS_SYMBOL } from 'morphism';\r\n *\r\n * const options: SchemaOptions = { class: { automapping: true }, undefinedValues: { strip: true } };\r\n * const schema: Schema = { targetProperty: 'sourceProperty', [SCHEMA_OPTIONS_SYMBOL]: options }\r\n\r\n * ```\r\n */\r\nexport const SCHEMA_OPTIONS_SYMBOL = Symbol('SchemaOptions');\r\n\r\nexport function isActionSelector<S, R>(value: any): value is ActionSelector<S, R> {\r\n  return isObject(value) && (value.hasOwnProperty('fn') || value.hasOwnProperty('path'));\r\n}\r\nexport function isActionString(value: any): value is string {\r\n  return isString(value);\r\n}\r\nexport function isActionAggregator(value: any): value is ActionAggregator {\r\n  return Array.isArray(value) && value.every(isActionString);\r\n}\r\nexport function isActionFunction(value: any): value is ActionFunction {\r\n  return isFunction(value);\r\n}\r\n\r\nexport function isValidAction(action: any) {\r\n  return isString(action) || isFunction(action) || isActionSelector(action) || isActionAggregator(action);\r\n}\r\n\r\nexport const aggregator = (paths: string[], object: any) => {\r\n  return paths.reduce((delta, path) => {\r\n    set(delta, path, get(object, path)); // TODO: ensure set will return the mutated object\r\n    return delta;\r\n  }, {});\r\n};\r\n\r\nexport function isUndefined(value: any) {\r\n  return value === undefined;\r\n}\r\n\r\nexport function isObject(value: any): value is object {\r\n  const type = typeof value;\r\n  return value != null && (type === 'object' || type === 'function');\r\n}\r\n\r\nexport function isString(value: any): value is string {\r\n  return typeof value === 'string' || value instanceof String;\r\n}\r\n\r\nexport function isFunction(value: any): value is (...args: any[]) => any {\r\n  return typeof value === 'function';\r\n}\r\n\r\nexport function isPromise(object: any) {\r\n  if (Promise && Promise.resolve) {\r\n    // tslint:disable-next-line:triple-equals\r\n    return Promise.resolve(object) == object;\r\n  } else {\r\n    throw new Error('Promise not supported in your environment');\r\n  }\r\n}\r\nexport function get(object: any, path: string) {\r\n  path = path.replace(/\\[(\\w+)\\]/g, '.$1'); // convert indexes to properties\r\n  path = path.replace(/^\\./, ''); // strip a leading dot\r\n  const a = path.split('.');\r\n  for (let i = 0, n = a.length; i < n; ++i) {\r\n    const k = a[i];\r\n    if (isObject(object) && k in object) {\r\n      object = (object as any)[k];\r\n    } else {\r\n      return;\r\n    }\r\n  }\r\n  return object;\r\n}\r\n\r\nexport function zipObject(props: string[], values: any[]) {\r\n  return props.reduce((prev, prop, i) => {\r\n    return { ...prev, [prop]: values[i] };\r\n  }, {});\r\n}\r\n\r\n// https://github.com/mariocasciaro/object-path/blob/master/index.js\r\nfunction hasOwnProperty(obj: any, prop: any) {\r\n  if (obj == null) {\r\n    return false;\r\n  }\r\n  // to handle objects with null prototypes (too edge case?)\r\n  return Object.prototype.hasOwnProperty.call(obj, prop);\r\n}\r\nfunction hasShallowProperty(obj: any, prop: any) {\r\n  return (typeof prop === 'number' && Array.isArray(obj)) || hasOwnProperty(obj, prop);\r\n}\r\nfunction getShallowProperty(obj: any, prop: any) {\r\n  if (hasShallowProperty(obj, prop)) {\r\n    return obj[prop];\r\n  }\r\n}\r\nexport function set(obj: any, path: any, value: any, doNotReplace?: boolean): any {\r\n  if (typeof path === 'number') {\r\n    path = [path];\r\n  }\r\n  if (!path || path.length === 0) {\r\n    return obj;\r\n  }\r\n  if (typeof path === 'string') {\r\n    return set(obj, path.split('.').map(getKey), value, doNotReplace);\r\n  }\r\n  const currentPath = path[0];\r\n  const currentValue = getShallowProperty(obj, currentPath);\r\n  if (path.length === 1) {\r\n    if (currentValue === void 0 || !doNotReplace) {\r\n      obj[currentPath] = value;\r\n    }\r\n    return currentValue;\r\n  }\r\n\r\n  if (currentValue === void 0) {\r\n    // check if we assume an array\r\n    if (typeof path[1] === 'number') {\r\n      obj[currentPath] = [];\r\n    } else {\r\n      obj[currentPath] = {};\r\n    }\r\n  }\r\n\r\n  return set(obj[currentPath], path.slice(1), value, doNotReplace);\r\n}\r\n\r\nfunction getKey(key: any) {\r\n  const intKey = parseInt(key);\r\n  if (intKey.toString() === key) {\r\n    return intKey;\r\n  }\r\n  return key;\r\n}\r\n\r\nexport function isEmptyObject(obj: object) {\r\n  for (const prop in obj) {\r\n    if (Object.prototype.hasOwnProperty.call(obj, prop)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n","import { ValidatorError } from '../morphism';\r\n\r\nexport const ERRORS = Symbol('errors');\r\n\r\nexport class ValidationError extends Error {\r\n  targetProperty: string;\r\n  innerError: ValidatorError;\r\n  constructor(infos: { targetProperty: string; innerError: ValidatorError }) {\r\n    super(`Invalid value supplied at property <${infos.targetProperty}>.`);\r\n    this.innerError = infos.innerError;\r\n  }\r\n}\r\n\r\nexport class ValidationErrors extends Error {\r\n  errors: Set<ValidationError>;\r\n  reporter: Reporter;\r\n  target: unknown;\r\n  constructor(reporter: Reporter, target: unknown) {\r\n    super();\r\n    this.errors = new Set<ValidationError>();\r\n    this.reporter = reporter;\r\n    this.target = target;\r\n  }\r\n  addError(error: ValidationError) {\r\n    this.errors.add(error);\r\n    const errors = this.reporter.report(this.target);\r\n    if (errors) {\r\n      this.message = errors.join('\\n');\r\n    }\r\n  }\r\n}\r\n\r\nexport interface Validation {\r\n  [ERRORS]: ValidationErrors;\r\n}\r\n\r\nexport function targetHasErrors(target: any): target is Validation {\r\n  return target && target[ERRORS] && target[ERRORS].errors.size > 0;\r\n}\r\nexport function defaultFormatter(error: ValidationError) {\r\n  const { message, innerError } = error;\r\n  return `${message} Reason: ${innerError.message}`;\r\n}\r\n\r\n/**\r\n * Formatting function called by the reporter for each errors found during the mapping towards a target.\r\n *\r\n * @interface Formatter\r\n */\r\nexport interface Formatter {\r\n  (error: ValidationError): string;\r\n}\r\n\r\n/**\r\n * Class to handle reporting of errors found on a target when executing a mapping.\r\n *\r\n * @class Reporter\r\n */\r\nexport class Reporter {\r\n  constructor(private formatter: Formatter = defaultFormatter) {}\r\n\r\n  /**\r\n   * Report a list of messages corresponding to the errors found during the transformations. Returns null when no errors has been found.\r\n   *\r\n   * @param {*} target\r\n   * @returns {string[] | null}\r\n   * @memberof Reporter\r\n   */\r\n  report(target: any): string[] | null {\r\n    const validationErrors = this.extractErrors(target);\r\n\r\n    if (!validationErrors) return null;\r\n    return [...validationErrors.errors.values()].map(this.formatter);\r\n  }\r\n\r\n  extractErrors(target: any) {\r\n    if (!targetHasErrors(target)) return null;\r\n    return target[ERRORS];\r\n  }\r\n}\r\n\r\n/**\r\n * Singleton instance of a Reporter class.\r\n *\r\n */\r\nexport const reporter = new Reporter();\r\n","import { Actions, Schema, StrictSchema, ValidatorValidateResult } from './types';\r\nimport {\r\n  aggregator,\r\n  get,\r\n  isValidAction,\r\n  isActionString,\r\n  isActionSelector,\r\n  isActionAggregator,\r\n  isActionFunction,\r\n  isFunction,\r\n  isString,\r\n  isObject,\r\n  SCHEMA_OPTIONS_SYMBOL,\r\n  isEmptyObject,\r\n} from './helpers';\r\nimport { ValidationError, ERRORS, targetHasErrors, ValidationErrors, reporter, Reporter } from './validation/reporter';\r\nimport { ValidatorError } from './validation/validators/ValidatorError';\r\nimport { isArray } from 'util';\r\n\r\nexport enum NodeKind {\r\n  Root = 'Root',\r\n  Property = 'Property',\r\n  ActionFunction = 'ActionFunction',\r\n  ActionAggregator = 'ActionAggregator',\r\n  ActionString = 'ActionString',\r\n  ActionSelector = 'ActionSelector',\r\n}\r\n\r\ntype PreparedAction = (params: { object: any; items: any; objectToCompute: any }) => any;\r\ninterface SchemaNodeData<Target, Source> {\r\n  propertyName: string;\r\n  action: Actions<Target, Source> | null;\r\n  preparedAction?: PreparedAction | null;\r\n  kind: NodeKind;\r\n  targetPropertyPath: string;\r\n}\r\nexport interface SchemaNode<Target, Source> {\r\n  data: SchemaNodeData<Target, Source>;\r\n  parent: SchemaNode<Target, Source> | null;\r\n  children: SchemaNode<Target, Source>[];\r\n}\r\n\r\ntype Overwrite<T1, T2> = { [P in Exclude<keyof T1, keyof T2>]: T1[P] } & T2;\r\n\r\ntype AddNode<Target, Source> = Overwrite<\r\n  SchemaNodeData<Target, Source>,\r\n  {\r\n    kind?: NodeKind;\r\n    targetPropertyPath?: string;\r\n    preparedAction?: (...args: any) => any;\r\n  }\r\n>;\r\n\r\n/**\r\n * Options attached to a `Schema` or `StrictSchema`\r\n */\r\nexport interface SchemaOptions<Target = any> {\r\n  /**\r\n   * Specify how to handle ES6 Class\r\n   * @memberof SchemaOptions\r\n   */\r\n  class?: {\r\n    /**\r\n     * Specify wether ES6 Class fields should be automapped if names on source and target match\r\n     * @default true\r\n     * @type {boolean}\r\n     */\r\n    automapping: boolean;\r\n  };\r\n  /**\r\n   * Specify how to handle undefined values mapped during the transformations\r\n   * @memberof SchemaOptions\r\n   */\r\n  undefinedValues?: {\r\n    /**\r\n     * Undefined values should be removed from the target\r\n     * @default false\r\n     * @type {boolean}\r\n     */\r\n    strip: boolean;\r\n    /**\r\n     * Optional callback to be executed for every undefined property on the Target\r\n     * @function default\r\n     */\r\n    default?: (target: Target, propertyPath: string) => any;\r\n  };\r\n  /**\r\n   * Schema validation options\r\n   * @memberof SchemaOptions\r\n   */\r\n  validation?: {\r\n    /**\r\n     * Should throw when property validation fails\r\n     * @default false\r\n     * @type {boolean}\r\n     */\r\n    throw: boolean;\r\n    /**\r\n     * Custom reporter to use when throw option is set to true\r\n     * @default false\r\n     * @type {boolean}\r\n     */\r\n    reporter?: Reporter;\r\n  };\r\n}\r\n\r\n/**\r\n * A utility function that allows defining a `StrictSchema` with extra-options e.g: how to handle `undefinedValues`\r\n *\r\n * @param {StrictSchema} schema\r\n * @param {SchemaOptions<Target>} [options]\r\n */\r\nexport function createSchema<Target = any, Source = any>(schema: StrictSchema<Target, Source>, options?: SchemaOptions<Target>) {\r\n  if (options && !isEmptyObject(options)) (schema as any)[SCHEMA_OPTIONS_SYMBOL] = options;\r\n  return schema;\r\n}\r\n\r\nexport class MorphismSchemaTree<Target, Source> {\r\n  schemaOptions: SchemaOptions<Target>;\r\n\r\n  root: SchemaNode<Target, Source>;\r\n  schema: Schema | StrictSchema | null;\r\n\r\n  constructor(schema: Schema<Target, Source> | StrictSchema<Target, Source> | null) {\r\n    this.schema = schema;\r\n    this.schemaOptions = MorphismSchemaTree.getSchemaOptions(this.schema);\r\n\r\n    this.root = {\r\n      data: {\r\n        targetPropertyPath: '',\r\n        propertyName: 'MorphismTreeRoot',\r\n        action: null,\r\n        kind: NodeKind.Root,\r\n      },\r\n      parent: null,\r\n      children: [],\r\n    };\r\n    if (schema) {\r\n      this.parseSchema(schema);\r\n    }\r\n  }\r\n\r\n  static getSchemaOptions<Target>(schema: Schema | StrictSchema | null): SchemaOptions<Target> {\r\n    const defaultSchemaOptions: SchemaOptions<Target> = {\r\n      class: { automapping: true },\r\n      undefinedValues: { strip: false },\r\n    };\r\n    const options = schema ? (schema as any)[SCHEMA_OPTIONS_SYMBOL] : undefined;\r\n\r\n    return { ...defaultSchemaOptions, ...options };\r\n  }\r\n\r\n  private parseSchema(partialSchema: Partial<Schema | StrictSchema> | string | number, actionKey?: string, parentKeyPath?: string): void {\r\n    if (isValidAction(partialSchema) && actionKey) {\r\n      this.add(\r\n        {\r\n          propertyName: actionKey,\r\n          action: partialSchema as Actions<Target, Source>,\r\n        },\r\n        parentKeyPath\r\n      );\r\n      parentKeyPath = parentKeyPath ? `${parentKeyPath}.${actionKey}` : actionKey;\r\n    } else {\r\n      if (actionKey) {\r\n        if (isObject(partialSchema) && isEmptyObject(partialSchema as any))\r\n          throw new Error(\r\n            `A value of a schema property can't be an empty object. Value ${JSON.stringify(partialSchema)} found for property ${actionKey}`\r\n          );\r\n        // check if actionKey exists to verify if not root node\r\n        this.add(\r\n          {\r\n            propertyName: actionKey,\r\n            action: partialSchema as Actions<Target, Source>,\r\n          },\r\n          parentKeyPath\r\n        );\r\n        parentKeyPath = parentKeyPath ? `${parentKeyPath}.${actionKey}` : actionKey;\r\n      }\r\n\r\n      if (Array.isArray(partialSchema)) {\r\n        partialSchema.forEach((subSchema, index) => {\r\n          this.parseSchema(subSchema, index.toString(), parentKeyPath);\r\n        });\r\n      } else if (isObject(partialSchema)) {\r\n        Object.keys(partialSchema).forEach(key => {\r\n          this.parseSchema((partialSchema as any)[key], key, parentKeyPath);\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  *traverseBFS() {\r\n    const queue: SchemaNode<Target, Source>[] = [];\r\n    queue.push(this.root);\r\n    while (queue.length > 0) {\r\n      let node = queue.shift();\r\n      if (node) {\r\n        for (let i = 0, length = node.children.length; i < length; i++) {\r\n          queue.push(node.children[i]);\r\n        }\r\n        if (node.data.kind !== NodeKind.Root) {\r\n          yield node;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  add(data: AddNode<Target, Source>, targetPropertyPath?: string) {\r\n    const kind = this.getActionKind(data);\r\n\r\n    const nodeToAdd: SchemaNode<Target, Source> = {\r\n      data: { ...data, kind, targetPropertyPath: '' },\r\n      parent: null,\r\n      children: [],\r\n    };\r\n    nodeToAdd.data.preparedAction = this.getPreparedAction(nodeToAdd.data);\r\n\r\n    if (!targetPropertyPath) {\r\n      nodeToAdd.parent = this.root;\r\n      nodeToAdd.data.targetPropertyPath = nodeToAdd.data.propertyName;\r\n      this.root.children.push(nodeToAdd);\r\n    } else {\r\n      for (const node of this.traverseBFS()) {\r\n        if (node.data.targetPropertyPath === targetPropertyPath) {\r\n          nodeToAdd.parent = node;\r\n          nodeToAdd.data.targetPropertyPath = `${node.data.targetPropertyPath}.${nodeToAdd.data.propertyName}`;\r\n          node.children.push(nodeToAdd);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  getActionKind(data: AddNode<Target, Source>) {\r\n    if (isActionString(data.action)) return NodeKind.ActionString;\r\n    if (isFunction(data.action)) return NodeKind.ActionFunction;\r\n    if (isActionSelector(data.action)) return NodeKind.ActionSelector;\r\n    if (isActionAggregator(data.action)) return NodeKind.ActionAggregator;\r\n    if (isObject(data.action)) return NodeKind.Property;\r\n    throw new Error(`The action specified for ${data.propertyName} is not supported.`);\r\n  }\r\n\r\n  getPreparedAction(nodeData: SchemaNodeData<Target, Source>): PreparedAction | null | undefined {\r\n    const { propertyName: targetProperty, action, kind } = nodeData;\r\n    // iterate on every action of the schema\r\n    if (isActionString(action)) {\r\n      // Action<String>: string path => [ target: 'source' ]\r\n      return ({ object }) => get(object, action);\r\n    } else if (isActionFunction(action)) {\r\n      // Action<Function>: Free Computin - a callback called with the current object and collection [ destination: (object) => {...} ]\r\n      return ({ object, items, objectToCompute }) => action.call(undefined, object, items, objectToCompute);\r\n    } else if (isActionAggregator(action)) {\r\n      // Action<Array>: Aggregator - string paths => : [ destination: ['source1', 'source2', 'source3'] ]\r\n      return ({ object }) => aggregator(action, object);\r\n    } else if (isActionSelector(action)) {\r\n      // Action<Object>: a path and a function: [ destination : { path: 'source', fn:(fieldValue, items) }]\r\n      return ({ object, items, objectToCompute }) => {\r\n        let targetValue: any;\r\n        if (action.path) {\r\n          if (Array.isArray(action.path)) {\r\n            targetValue = aggregator(action.path, object);\r\n          } else if (isString(action.path)) {\r\n            targetValue = get(object, action.path);\r\n          }\r\n        } else {\r\n          targetValue = object;\r\n        }\r\n\r\n        if (action.fn) {\r\n          try {\r\n            targetValue = action.fn.call(undefined, targetValue, object, items, objectToCompute);\r\n          } catch (e: any) {\r\n            e.message = `Unable to set target property [${targetProperty}].\r\n            \\n An error occured when applying [${action.fn.name}] on property [${action.path}]\r\n            \\n Internal error: ${e.message}`;\r\n            throw e;\r\n          }\r\n        }\r\n\r\n        if (action.validation) {\r\n          const validationResult = action.validation({ value: targetValue });\r\n\r\n          this.processValidationResult(validationResult, targetProperty, objectToCompute);\r\n          targetValue = validationResult.value;\r\n        }\r\n        return targetValue;\r\n      };\r\n    } else if (kind === NodeKind.Property) {\r\n      return null;\r\n    }\r\n  }\r\n  private processValidationResult(validationResult: ValidatorValidateResult, targetProperty: string, objectToCompute: any) {\r\n    if (validationResult.error) {\r\n      const error = validationResult.error;\r\n      if (error instanceof ValidatorError) {\r\n        this.addErrorToTarget(targetProperty, error, objectToCompute);\r\n      } else {\r\n        throw error;\r\n      }\r\n    }\r\n  }\r\n\r\n  private addErrorToTarget(targetProperty: string, error: ValidatorError, objectToCompute: any) {\r\n    const validationError = new ValidationError({\r\n      targetProperty,\r\n      innerError: error,\r\n    });\r\n\r\n    if (targetHasErrors(objectToCompute)) {\r\n      objectToCompute[ERRORS].addError(validationError);\r\n    } else {\r\n      if (this.schemaOptions.validation && this.schemaOptions.validation.reporter) {\r\n        objectToCompute[ERRORS] = new ValidationErrors(this.schemaOptions.validation.reporter, objectToCompute);\r\n      } else {\r\n        objectToCompute[ERRORS] = new ValidationErrors(reporter, objectToCompute);\r\n      }\r\n      objectToCompute[ERRORS].addError(validationError);\r\n    }\r\n  }\r\n}\r\n","export interface ValidatorErrorInfos {\r\n  value: unknown;\r\n  expect: string;\r\n}\r\nexport class ValidatorError extends Error {\r\n  value: unknown;\r\n  expect: string;\r\n  constructor(infos: ValidatorErrorInfos) {\r\n    super(infos.expect);\r\n    this.value = infos.value;\r\n    this.expect = infos.expect;\r\n  }\r\n}\r\n","import { Mapper } from './types';\r\nimport { isPromise } from './helpers';\r\n\r\nexport function decorator<Target>(mapper: Mapper<Target>) {\r\n  return (_target: any, _name: string, descriptor: PropertyDescriptor) => {\r\n    const fn = descriptor.value;\r\n    if (typeof fn === 'function') {\r\n      descriptor.value = function(...args: any[]) {\r\n        const output = fn.apply(this, args);\r\n        if (isPromise(output)) {\r\n          return Promise.resolve(output).then(res => mapper(res));\r\n        }\r\n        return mapper(output);\r\n      };\r\n    }\r\n\r\n    return descriptor;\r\n  };\r\n}\r\n","export class LinkedList<T> {\r\n  next: LinkedList<T> | null;\r\n  head: LinkedList<T> | null;\r\n  tail: LinkedList<T>;\r\n  constructor(private data: T) {\r\n    this.next = null;\r\n    this.head = this;\r\n    this.tail = this;\r\n  }\r\n\r\n  append(data: T) {\r\n    this.tail.next = new LinkedList(data);\r\n    this.tail = this.tail.next;\r\n  }\r\n\r\n  *values() {\r\n    while (this.head !== null) {\r\n      yield this.head.data;\r\n      this.head = this.head.next;\r\n    }\r\n  }\r\n}\r\n","import { ValidatorError } from './ValidatorError';\r\nimport { isString } from '../../helpers';\r\nimport { ValidatorValidateResult, ValidateFunction } from '../../types';\r\nimport { ValidatorOptions, Rule } from './types';\r\nimport { LinkedList } from './LinkedList';\r\n\r\nexport function StringValidator(options: ValidatorOptions = {}) {\r\n  let list = new LinkedList<Rule<string>>({\r\n    name: 'string',\r\n    expect: input => `Expected value to be a <string> but received <${input.value}>`,\r\n    validate: input => {\r\n      if (isString(input.value)) {\r\n        return true;\r\n      } else {\r\n        if (options.convert) {\r\n          input.value = String(input.value);\r\n          return true;\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n    },\r\n  });\r\n\r\n  const validate: ValidateFunction = input => {\r\n    const result: ValidatorValidateResult = input;\r\n    const iterator = list.values();\r\n    let current = iterator.next();\r\n    const usedRules: { [id: string]: Rule<string> } = {};\r\n\r\n    while (!result.error && !current.done) {\r\n      const rule = current.value;\r\n      if (rule.name in usedRules) {\r\n        throw new Error(`Rule ${rule.name} has already been used`);\r\n      } else {\r\n        usedRules[rule.name] = rule;\r\n      }\r\n      if (!rule.validate(result)) {\r\n        result.error = new ValidatorError({\r\n          expect: isString(rule.expect) ? rule.expect : rule.expect(result),\r\n          value: result.value,\r\n        });\r\n      }\r\n      current = iterator.next();\r\n    }\r\n    return result;\r\n  };\r\n\r\n  const rules = {\r\n    min: (value: number) => {\r\n      list.append({\r\n        name: 'min',\r\n        expect: input => `Expected value to be greater or equal than <${value}> but received <${input.value}>`,\r\n        validate: input => input.value.length >= value,\r\n      });\r\n      return api;\r\n    },\r\n    max: (value: number) => {\r\n      list.append({\r\n        name: 'max',\r\n        expect: input => `Expected value to be less or equal than <${value}> but received <${input.value}>`,\r\n        validate: input => input.value.length <= value,\r\n      });\r\n      return api;\r\n    },\r\n    size: (value: number) => {\r\n      list.append({\r\n        name: 'length',\r\n        expect: input => `Expected value to be length of <${value}> but received <${input.value}>`,\r\n        validate: input => input.value.length === value,\r\n      });\r\n      return api;\r\n    },\r\n    regex: (regex: RegExp) => {\r\n      const rule = createRegexRule('regex', input => `Expected value to match pattern: ${regex} but received <${input.value}>`, regex);\r\n      list.append(rule);\r\n      return api;\r\n    },\r\n    alphanum: () => {\r\n      const rule = createRegexRule(\r\n        'regex',\r\n        input => `Expected value to contain only alphanumeric characters but received <${input.value}>`,\r\n        /^[a-z0-9]+$/i\r\n      );\r\n      list.append(rule);\r\n      return api;\r\n    },\r\n  };\r\n  const api = Object.assign(validate, rules);\r\n  return api;\r\n}\r\n\r\nfunction createRegexRule(name: Rule['name'], expect: Rule['expect'], regex: RegExp): Rule<string> {\r\n  const validate: Rule<string>['validate'] = input => regex.test(input.value);\r\n  return { name, expect, validate };\r\n}\r\n","import { StringValidator, BooleanValidator, NumberValidator } from './validators';\r\n\r\ntype ValidatorsMap = Omit<IValidation, 'addValidator'>;\r\ntype Validators = IValidation[keyof ValidatorsMap];\r\ntype ValidatorsKeys = keyof ValidatorsMap;\r\n\r\nexport interface IValidation {\r\n  string: typeof StringValidator;\r\n  number: typeof NumberValidator;\r\n  boolean: typeof BooleanValidator;\r\n  addValidator<T extends ValidatorsKeys, U extends Validators>(name: T, validator: U): void;\r\n}\r\n\r\nconst handler: ProxyHandler<IValidation> = {\r\n  get: (object, prop: ValidatorsKeys & keyof IValidation) => {\r\n    if (prop in object) {\r\n      return object[prop];\r\n    } else if (validators.has(prop)) {\r\n      return validators.get(prop);\r\n    } else {\r\n      throw new Error(`The validator ${prop}() does not exist. Did you forget to call Validation.addValidator(name, validator)`);\r\n    }\r\n  },\r\n};\r\n\r\nconst validators = new Map<ValidatorsKeys, Validators>();\r\nconst Validation = new Proxy(\r\n  {\r\n    addValidator: (name, validator) => {\r\n      validators.set(name, validator);\r\n    },\r\n  } as IValidation,\r\n  handler\r\n);\r\nValidation.addValidator('string', StringValidator);\r\nValidation.addValidator('number', NumberValidator);\r\nValidation.addValidator('boolean', BooleanValidator);\r\n\r\nexport { Validation };\r\n","/**\r\n * @module morphism\r\n */\r\nimport { zipObject, isUndefined, get, set, SCHEMA_OPTIONS_SYMBOL } from './helpers';\r\nimport { Schema, StrictSchema, Constructable, SourceFromSchema, Mapper, DestinationFromSchema } from './types';\r\nimport { MorphismSchemaTree, createSchema, SchemaOptions } from './MorphismTree';\r\nimport { MorphismRegistry, IMorphismRegistry } from './MorphismRegistry';\r\nimport { decorator } from './MorphismDecorator';\r\nimport { Reporter, reporter as defaultReporter, Formatter, targetHasErrors, ValidationErrors } from './validation/reporter';\r\nimport { Validation, IValidation } from './validation/Validation';\r\nimport { ValidatorError } from './validation/validators/ValidatorError';\r\nimport { Rule } from './validation/validators/types';\r\n\r\n/**\r\n * Low Level transformer function.\r\n * Take a plain object as input and transform its values using a specified schema.\r\n * @param  {Object} object\r\n * @param  {Map<string, string> | Map<string, Function>} schema Transformation schema\r\n * @param  {Array} items Items to be forwarded to Actions\r\n * @param  {} objectToCompute Created tranformed object of a given type\r\n */\r\nfunction transformValuesFromObject<Source, Target>(\r\n  object: Source,\r\n  tree: MorphismSchemaTree<Target, Source>,\r\n  items: Source[],\r\n  objectToCompute: Target\r\n) {\r\n  const options = tree.schemaOptions;\r\n  const transformChunks = [];\r\n\r\n  for (const node of tree.traverseBFS()) {\r\n    const { preparedAction, targetPropertyPath } = node.data;\r\n    if (preparedAction)\r\n      transformChunks.push({\r\n        targetPropertyPath,\r\n        preparedAction: preparedAction({ object, objectToCompute, items }),\r\n      });\r\n  }\r\n\r\n  return transformChunks.reduce((finalObject, chunk) => {\r\n    const undefinedValueCheck = (destination: any, source: any) => {\r\n      // Take the Object class value property if the incoming property is undefined\r\n      if (isUndefined(source)) {\r\n        if (!isUndefined(destination)) {\r\n          return destination;\r\n        } else {\r\n          return; // No Black Magic Fuckery here, if the source and the destination are undefined, we don't do anything\r\n        }\r\n      } else {\r\n        return source;\r\n      }\r\n    };\r\n\r\n    const finalValue = undefinedValueCheck(get(finalObject, chunk.targetPropertyPath), chunk.preparedAction);\r\n    if (finalValue === undefined) {\r\n      // strip undefined values\r\n      if (options && options.undefinedValues && options.undefinedValues.strip) {\r\n        if (options.undefinedValues.default) {\r\n          set(finalObject, chunk.targetPropertyPath, options.undefinedValues.default(finalObject, chunk.targetPropertyPath));\r\n        }\r\n      } else {\r\n        // do not strip undefined values\r\n        set(finalObject, chunk.targetPropertyPath, finalValue);\r\n      }\r\n      checkIfValidationShouldThrow<Target>(options, finalObject);\r\n      return finalObject;\r\n    } else {\r\n      set(finalObject, chunk.targetPropertyPath, finalValue);\r\n      checkIfValidationShouldThrow<Target>(options, finalObject);\r\n      return finalObject;\r\n    }\r\n  }, objectToCompute);\r\n}\r\n\r\nfunction checkIfValidationShouldThrow<Target>(options: SchemaOptions<Target>, finalObject: Target) {\r\n  if (options && options.validation && options.validation.throw) {\r\n    if (targetHasErrors(finalObject)) {\r\n      let errors: ValidationErrors | null;\r\n      if (options.validation.reporter) {\r\n        const reporter = options.validation.reporter;\r\n        errors = reporter.extractErrors(finalObject);\r\n      } else {\r\n        errors = defaultReporter.extractErrors(finalObject);\r\n      }\r\n      if (errors) {\r\n        throw errors;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction transformItems<T, TSchema extends Schema<T>>(schema: TSchema, type?: Constructable<T>) {\r\n  const options = MorphismSchemaTree.getSchemaOptions<T>(schema);\r\n  let tree: MorphismSchemaTree<any, any>;\r\n  if (type && options.class && options.class.automapping) {\r\n    const finalSchema = getSchemaForClass(type, schema);\r\n    tree = new MorphismSchemaTree(finalSchema);\r\n  } else {\r\n    tree = new MorphismSchemaTree(schema);\r\n  }\r\n\r\n  const mapper: Mapper<TSchema> = (source: any) => {\r\n    if (!source) {\r\n      return source;\r\n    }\r\n    if (Array.isArray(source)) {\r\n      return source.map(obj => {\r\n        if (type) {\r\n          const classObject = new type();\r\n          return transformValuesFromObject(obj, tree, source, classObject);\r\n        } else {\r\n          const jsObject = {};\r\n          return transformValuesFromObject(obj, tree, source, jsObject);\r\n        }\r\n      });\r\n    } else {\r\n      const object = source;\r\n      if (type) {\r\n        const classObject = new type();\r\n        return transformValuesFromObject<any, T>(object, tree, [object], classObject);\r\n      } else {\r\n        const jsObject = {};\r\n        return transformValuesFromObject(object, tree, [object], jsObject);\r\n      }\r\n    }\r\n  };\r\n\r\n  return mapper;\r\n}\r\n\r\nfunction getSchemaForClass<T>(type: Constructable<T>, baseSchema: Schema<T>): Schema<T> {\r\n  let typeFields = Object.keys(new type());\r\n  let defaultSchema = zipObject(typeFields, typeFields);\r\n  let finalSchema = Object.assign(defaultSchema, baseSchema);\r\n  return finalSchema;\r\n}\r\n\r\n/**\r\n * Currying function that either outputs a mapping function or the transformed data.\r\n *\r\n * @example\r\n * ```js\r\n *\r\n  // => Outputs a function when only a schema is provided\r\n  const fn = morphism(schema);\r\n  const result = fn(data);\r\n\r\n  // => Outputs the transformed data when a schema and the input data is provided\r\n  const result = morphism(schema, data);\r\n\r\n  // => Outputs the transformed data as an ES6 Class Object when a schema, the input data and an ES6 Class are provided\r\n  const result = morphism(schema, data, Foo);\r\n  // result is type of Foo\r\n * ```\r\n * @param  {Schema} schema Structure-preserving object from a source data towards a target data\r\n * @param  {} items Object or Collection to be mapped\r\n * @param  {} type\r\n *\r\n */\r\nfunction morphism<\r\n  TSchema = Schema<DestinationFromSchema<Schema>, SourceFromSchema<Schema>>,\r\n  Source extends SourceFromSchema<TSchema> = SourceFromSchema<TSchema>\r\n>(schema: TSchema, data: Source[]): DestinationFromSchema<TSchema>[];\r\n\r\nfunction morphism<\r\n  TSchema = Schema<DestinationFromSchema<Schema>, SourceFromSchema<Schema>>,\r\n  Source extends SourceFromSchema<TSchema> = SourceFromSchema<TSchema>\r\n>(schema: TSchema, data: Source): DestinationFromSchema<TSchema>;\r\n\r\nfunction morphism<TSchema = Schema<DestinationFromSchema<Schema>, SourceFromSchema<Schema>>>(schema: TSchema): Mapper<TSchema>; // morphism({}) => mapper(S) => T\r\n\r\nfunction morphism<TSchema extends Schema, TDestination>(\r\n  schema: TSchema,\r\n  items: null,\r\n  type: Constructable<TDestination>\r\n): Mapper<TSchema, TDestination>; // morphism({}, null, T) => mapper(S) => T\r\n\r\nfunction morphism<\r\n  TSchema = Schema<DestinationFromSchema<Schema>, SourceFromSchema<Schema>>,\r\n  Target = never,\r\n  Source extends SourceFromSchema<TSchema> = SourceFromSchema<TSchema>\r\n>(schema: TSchema, items: Source, type: Constructable<Target>): Target; // morphism({}, {}, T) => T\r\n\r\nfunction morphism<\r\n  TSchema = Schema<DestinationFromSchema<Schema>, SourceFromSchema<Schema>>,\r\n  Target = never,\r\n  Source extends SourceFromSchema<TSchema> = SourceFromSchema<TSchema>\r\n>(schema: TSchema, items: Source[], type: Constructable<Target>): Target[]; // morphism({}, [], T) => T[]\r\n\r\nfunction morphism<Target, Source, TSchema extends Schema<Target, Source>>(\r\n  schema: TSchema,\r\n  items?: SourceFromSchema<TSchema> | null,\r\n  type?: Constructable<Target>\r\n) {\r\n  switch (arguments.length) {\r\n    case 1: {\r\n      return transformItems(schema);\r\n    }\r\n    case 2: {\r\n      return transformItems(schema)(items);\r\n    }\r\n    case 3: {\r\n      if (type) {\r\n        if (items !== null) return transformItems(schema, type)(items); // TODO: deprecate this option morphism(schema,null,Type) in favor of createSchema({},options={class: Type})\r\n        return transformItems(schema, type);\r\n      } else {\r\n        throw new Error(`When using morphism(schema, items, type), type should be defined but value received is ${type}`);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Decorators\r\n/**\r\n * Function Decorator transforming the return value of the targeted Function using the provided Schema and/or Type\r\n *\r\n * @param {Schema<Target>} schema Structure-preserving object from a source data towards a target data\r\n * @param {Constructable<Target>} [type] Target Class Type\r\n */\r\nexport function morph<Target>(schema: Schema<Target>, type?: Constructable<Target>) {\r\n  const mapper = transformItems(schema, type);\r\n  return decorator(mapper);\r\n}\r\n/**\r\n * Function Decorator transforming the return value of the targeted Function to JS Object(s) using the provided Schema\r\n *\r\n * @param {StrictSchema<Target>} schema Structure-preserving object from a source data towards a target data\r\n */\r\nexport function toJSObject<Target>(schema: StrictSchema<Target>) {\r\n  const mapper = transformItems(schema);\r\n  return decorator(mapper);\r\n}\r\n/**\r\n * Function Decorator transforming the return value of the targeted Function using the provided Schema and Class Type\r\n *\r\n * @param {Schema<Target>} schema Structure-preserving object from a source data towards a target data\r\n * @param {Constructable<Target>} [type] Target Class Type\r\n */\r\nexport function toClassObject<Target>(schema: Schema<Target>, type: Constructable<Target>) {\r\n  const mapper = transformItems(schema, type);\r\n  return decorator(mapper);\r\n}\r\n\r\n// Registry\r\nconst morphismRegistry = new MorphismRegistry();\r\nconst morphismMixin: typeof morphism & any = morphism;\r\nmorphismMixin.register = (t: any, s: any) => morphismRegistry.register(t, s);\r\nmorphismMixin.map = (t: any, d: any) => morphismRegistry.map(t, d);\r\nmorphismMixin.getMapper = (t: any) => morphismRegistry.getMapper(t);\r\nmorphismMixin.setMapper = (t: any, s: any) => morphismRegistry.setMapper(t, s);\r\nmorphismMixin.deleteMapper = (t: any) => morphismRegistry.deleteMapper(t);\r\nmorphismMixin.mappers = morphismRegistry.mappers;\r\n\r\nconst Morphism: typeof morphism & IMorphismRegistry = morphismMixin;\r\n\r\nexport {\r\n  morphism,\r\n  createSchema,\r\n  Schema,\r\n  StrictSchema,\r\n  SchemaOptions,\r\n  Mapper,\r\n  SCHEMA_OPTIONS_SYMBOL,\r\n  Reporter,\r\n  defaultReporter as reporter,\r\n  Formatter,\r\n  Validation,\r\n  Rule,\r\n  ValidatorError,\r\n  IValidation,\r\n};\r\nexport default Morphism;\r\n","import { ValidatorValidateResult, ValidateFunction } from '../../types';\r\nimport { LinkedList } from './LinkedList';\r\nimport { ValidatorOptions, Rule } from './types';\r\nimport { ValidatorError } from './ValidatorError';\r\nimport { isString } from '../../helpers';\r\n\r\nexport function NumberValidator(options: ValidatorOptions = {}) {\r\n  let list = new LinkedList<Rule<number>>({\r\n    name: 'number',\r\n    expect: input => `Expected value to be a <number> but received <${input.value}>`,\r\n    validate: input => {\r\n      if (!options.convert) {\r\n        return typeof input.value === 'number';\r\n      } else {\r\n        input.value = +input.value;\r\n        return !isNaN(input.value);\r\n      }\r\n    },\r\n  });\r\n\r\n  const validate: ValidateFunction = input => {\r\n    const result: ValidatorValidateResult = input;\r\n    const iterator = list.values();\r\n    let current = iterator.next();\r\n    const usedRules: { [id: string]: Rule<number> } = {};\r\n\r\n    while (!result.error && !current.done) {\r\n      const rule = current.value;\r\n      if (rule.name in usedRules) {\r\n        throw new Error(`Rule ${rule.name} has already been used`);\r\n      } else {\r\n        usedRules[rule.name] = rule;\r\n      }\r\n      if (!rule.validate(result)) {\r\n        result.error = new ValidatorError({\r\n          expect: isString(rule.expect) ? rule.expect : rule.expect(result),\r\n          value: result.value,\r\n        });\r\n      }\r\n      current = iterator.next();\r\n    }\r\n    return result;\r\n  };\r\n\r\n  const rules = {\r\n    min: (value: any) => {\r\n      list.append({\r\n        name: 'min',\r\n        expect: `value to be greater or equal than ${value}`,\r\n        validate: input => input.value >= value,\r\n      });\r\n      return api;\r\n    },\r\n    max: (value: any) => {\r\n      list.append({\r\n        name: 'max',\r\n        expect: `value to be less or equal than ${value}`,\r\n        validate: input => input.value <= value,\r\n      });\r\n      return api;\r\n    },\r\n  };\r\n  const api = Object.assign(validate, rules);\r\n  return api;\r\n}\r\n","import { ValidatorError } from './ValidatorError';\r\nimport { isFunction, isString } from '../../helpers';\r\nimport { ValidatorOptions, Rule } from './types';\r\nimport { LinkedList } from './LinkedList';\r\nimport { ValidatorValidateResult, ValidateFunction } from '../../types';\r\n\r\nexport function BooleanValidator(options: ValidatorOptions = {}) {\r\n  let list = new LinkedList<Rule<boolean>>({\r\n    name: 'boolean',\r\n    expect: input => `Expected value to be a <boolean> but received <${input.value}>`,\r\n    validate: input => {\r\n      if (!options.convert) {\r\n        return typeof input.value === 'boolean';\r\n      } else {\r\n        if (typeof input.value === 'boolean') {\r\n          return input.value;\r\n        } else {\r\n          if (/true/i.test(input.value)) {\r\n            input.value = true;\r\n            return true;\r\n          } else if (/false/i.test(input.value)) {\r\n            input.value = false;\r\n            return true;\r\n          } else {\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n    },\r\n  });\r\n\r\n  const validate: ValidateFunction = input => {\r\n    const result: ValidatorValidateResult = input;\r\n    const iterator = list.values();\r\n    let current = iterator.next();\r\n    const usedRules: { [id: string]: Rule<boolean> } = {};\r\n\r\n    while (!result.error && !current.done) {\r\n      const rule = current.value;\r\n      if (rule.name in usedRules) {\r\n        throw new Error(`Rule ${rule.name} has already been used`);\r\n      } else {\r\n        usedRules[rule.name] = rule;\r\n      }\r\n      if (!rule.validate(result)) {\r\n        result.error = new ValidatorError({\r\n          expect: isString(rule.expect) ? rule.expect : rule.expect(result),\r\n          value: result.value,\r\n        });\r\n      }\r\n      current = iterator.next();\r\n    }\r\n    return result;\r\n  };\r\n\r\n  const rules = {};\r\n  const api = Object.assign(validate, rules);\r\n  return api;\r\n}\r\n","import { Constructable, Schema, Mapper } from './types';\r\nimport { morphism } from './morphism';\r\n\r\nexport interface IMorphismRegistry {\r\n  /**\r\n   * Register a mapping schema for a Class.\r\n   *\r\n   * @param type Class Type to be registered\r\n   * @param schema Structure-preserving object from a source data towards a target data.\r\n   *\r\n   */\r\n  register<Target>(type: Constructable<Target>): Mapper<Schema<Target>, Target>;\r\n  register<Target, TSchema>(type: Constructable<Target>, schema?: TSchema): Mapper<TSchema, Target>;\r\n\r\n  /**\r\n   * Transform any input in the specified Class\r\n   *\r\n   * @param {Type} type Class Type of the ouput Data\r\n   * @param {Object} data Input data to transform\r\n   *\r\n   */\r\n  map<Target>(type: Constructable<Target>): Mapper<Schema, Target>;\r\n  map<Target, Source>(type: Constructable<Target>, data: Source[]): Target[];\r\n  map<Target, Source>(type: Constructable<Target>, data: Source): Target;\r\n  /**\r\n   * Get a specific mapping function for the provided Class\r\n   *\r\n   * @param {Type} type Class Type of the ouput Data\r\n   *\r\n   */\r\n  getMapper<Target>(type: Constructable<Target>): Mapper<Schema, Target>;\r\n  /**\r\n   * Set a schema for a specific Class Type\r\n   *\r\n   * @param {Type} type Class Type of the ouput Data\r\n   * @param {Schema} schema Class Type of the ouput Data\r\n   *\r\n   */\r\n  setMapper<Target, TSchema extends Schema<Target>>(type: Constructable<Target>, schema: TSchema): Mapper<any, Target>;\r\n  /**\r\n   * Delete a registered schema associated to a Class\r\n   *\r\n   * @param type ES6 Class Type of the ouput Data\r\n   *\r\n   */\r\n  deleteMapper<Target>(type: Constructable<Target>): any;\r\n  /**\r\n   * Check if a schema has already been registered for this type\r\n   *\r\n   * @param {*} type\r\n   */\r\n  exists<Target>(type: Target): boolean;\r\n  /**\r\n   * Get the list of the mapping functions registered\r\n   *\r\n   * @param {Type} type Class Type of the ouput Data\r\n   *\r\n   */\r\n  mappers: Map<any, any>;\r\n}\r\n\r\nexport class MorphismRegistry implements IMorphismRegistry {\r\n  private _registry: any = null;\r\n  /**\r\n   *Creates an instance of MorphismRegistry.\r\n   * @param {Map<any, any>} cache Cache implementation to store the mapping functions.\r\n   */\r\n  constructor() {\r\n    this._registry = { cache: new Map() };\r\n  }\r\n\r\n  /**\r\n   * Register a mapping schema for a Class.\r\n   *\r\n   * @param type Class Type to be registered\r\n   * @param schema Structure-preserving object from a source data towards a target data.\r\n   *\r\n   */\r\n  register<Target, TSchema>(type: Constructable<Target>, schema?: TSchema) {\r\n    if (!type && !schema) {\r\n      throw new Error('type paramater is required when you register a mapping');\r\n    } else if (this.exists(type)) {\r\n      throw new Error(`A mapper for ${type.name} has already been registered`);\r\n    }\r\n    let mapper;\r\n    if (schema) {\r\n      mapper = morphism(schema, null, type);\r\n    } else {\r\n      mapper = morphism({}, null, type);\r\n    }\r\n    this._registry.cache.set(type, mapper);\r\n    return mapper;\r\n  }\r\n  /**\r\n   * Transform any input in the specified Class\r\n   *\r\n   * @param {Type} type Class Type of the ouput Data\r\n   * @param {Object} data Input data to transform\r\n   *\r\n   */\r\n  map(type: any, data?: any) {\r\n    if (!this.exists(type)) {\r\n      const mapper = this.register(type);\r\n      if (data === undefined) {\r\n        return mapper;\r\n      }\r\n    }\r\n    return this.getMapper(type)(data);\r\n  }\r\n  /**\r\n   * Get a specific mapping function for the provided Class\r\n   *\r\n   * @param {Type} type Class Type of the ouput Data\r\n   *\r\n   */\r\n  getMapper<Target>(type: Constructable<Target>) {\r\n    return this._registry.cache.get(type);\r\n  }\r\n  /**\r\n   * Set a schema for a specific Class Type\r\n   *\r\n   * @param {Type} type Class Type of the ouput Data\r\n   * @param {Schema} schema Class Type of the ouput Data\r\n   *\r\n   */\r\n  setMapper<Target>(type: Constructable<Target>, schema: Schema<Target>) {\r\n    if (!schema) {\r\n      throw new Error(`The schema must be an Object. Found ${schema}`);\r\n    } else if (!this.exists(type)) {\r\n      throw new Error(`The type ${type.name} is not registered. Register it using \\`Mophism.register(${type.name}, schema)\\``);\r\n    } else {\r\n      let fn = morphism(schema, null, type);\r\n      this._registry.cache.set(type, fn);\r\n      return fn;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a registered schema associated to a Class\r\n   *\r\n   * @param type ES6 Class Type of the ouput Data\r\n   *\r\n   */\r\n  deleteMapper(type: any) {\r\n    return this._registry.cache.delete(type);\r\n  }\r\n\r\n  /**\r\n   * Check if a schema has already been registered for this type\r\n   *\r\n   * @param {*} type\r\n   */\r\n  exists(type: any) {\r\n    return this._registry.cache.has(type);\r\n  }\r\n  /**\r\n   * Get the list of the mapping functions registered\r\n   *\r\n   * @param {Type} type Class Type of the ouput Data\r\n   *\r\n   */\r\n  get mappers() {\r\n    return this._registry.cache as Map<any, any>;\r\n  }\r\n}\r\n"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","SCHEMA_OPTIONS_SYMBOL","isActionSelector","isObject","isActionString","isString","isActionAggregator","Array","isArray","every","aggregator","paths","object","reduce","delta","path","set","isUndefined","undefined","type","String","isFunction","isPromise","Promise","resolve","Error","a","replace","split","i","n","length","k","doNotReplace","map","getKey","currentPath","currentValue","hasShallowProperty","getShallowProperty","slice","intKey","parseInt","toString","isEmptyObject","ERRORS","ValidationError","constructor","infos","super","targetProperty","innerError","ValidationErrors","reporter","target","errors","Set","addError","error","add","report","message","join","targetHasErrors","size","defaultFormatter","Reporter","formatter","validationErrors","extractErrors","values","NodeKind","ValidatorError","expect","createSchema","schema","options","MorphismSchemaTree","schemaOptions","getSchemaOptions","data","targetPropertyPath","propertyName","action","kind","Root","parent","children","parseSchema","class","automapping","undefinedValues","strip","partialSchema","actionKey","parentKeyPath","JSON","stringify","forEach","subSchema","index","keys","queue","push","node","shift","getActionKind","nodeToAdd","preparedAction","getPreparedAction","traverseBFS","ActionString","ActionFunction","ActionSelector","ActionAggregator","Property","nodeData","items","objectToCompute","targetValue","fn","e","name","validation","validationResult","processValidationResult","addErrorToTarget","validationError","decorator","mapper","_target","_name","descriptor","args","output","apply","then","res","LinkedList","next","head","tail","append","createRegexRule","regex","validate","input","test","handler","validators","has","Map","Validation","Proxy","addValidator","validator","transformValuesFromObject","tree","transformChunks","finalObject","chunk","destination","source","finalValue","default","checkIfValidationShouldThrow","throw","defaultReporter","transformItems","finalSchema","baseSchema","typeFields","defaultSchema","prev","assign","getSchemaForClass","classObject","morphism","arguments","morph","toJSObject","toClassObject","list","convert","result","iterator","current","usedRules","done","rule","rules","min","api","max","alphanum","isNaN","morphismRegistry","_registry","cache","register","exists","getMapper","setMapper","deleteMapper","delete","mappers","morphismMixin","t","s","d"],"sourceRoot":""}